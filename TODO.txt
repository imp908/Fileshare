I:
0 Repo (against SQL base and Northwind base)
-> IRepository<T> with CRUD operations lightweight
-> Specific repository for every entity
-> UOW
	bind repo to generic with as and type conversion
	bind context to every repo
0 WCF
-> Add WCF between Repo and Site
POCO to DataContract converter
ServiceContract Operation contract(implementation utilises repo) - Iservice - Irepo (IUow)
-> Add BLL Business logic layer between POCOs and UOW
-> Add JS multiple model items update at one time
-> to DLL
0 WebAPI
-> between repo and MVC site
1 PresentationSite
-> parsing excel file to objects method decompose to several
	///Sector type from filename
	///Fist file input determines merchant sector
	parse file mask;
	
	if parsed then
	{
	
		get sector id from filename; --from config
		get property fields; --from config
		if(no merchant column then error); --from parser

		foreach row
		{
			check merchant doubles for this sector; --from UOF
			remove doubles; --from UOF
			insert; --from UOF
		}
		
	}

-> Export to excel
-> Type converter for migration (
Add SQL to CLR type conversion ; 
SQLEntity to DWH entity converter; 
Converter logic to string name or type name;)

SB , Repo and UOF to different projects  <- done
Northwind -> change login employee get from TempData to model  <- done
Northwind -> add complex model add  <- done
Tables migration - test with repo <- done
-> Emplicit implicit repos
1-explicit repo (mostly type by merchant)
Repo<T>() { GetItem1<T>() where T: IOne{}; ... GetItemn<T>() where T: In{}}
2-implicit repo (mostly one type by repo instance)
Repo<T>() where T: IOne { GetByOne(); }
...
Repo<T>() where T: In { GetByN(); } <- done

II:
0 Polinom Parse -> parse *^/ to expressions and add priorities for exprs
0 Command line app dll -> to SB
0 Multithread socket message ping pong -> to SB
0 Console parameters parse -> to SB
0 CollectionsComparison -> to SB